$wnd.gwtmaterialdemo.runAsyncCallback10("function w_b(){}\nfunction Isd(a){this.a=a}\nfunction Ksd(a){this.a=a}\nfunction Msd(a){this.a=a}\nfunction Osd(a){this.a=a}\nfunction z_b(){z_b=Kqb;v_b=new w_b}\nfunction q_b(){o_b();n_b.call(this);this.b=new $wnd.Object}\nfunction Fsd(){xFb.call(this);vFb(this,Gsd(new Hsd(this)))}\nfunction ysd(a,b,c){IEb();fFb.call(this,a,b,c,(Phd(),Nhd))}\nfunction p_b(a,b){$wnd.$(ho(zD(a.D,205))).mask(b,a.b)}\nfunction Ssd(a){var b;if(!a.d){b=new Fsd;a.d=b}return a.d}\nfunction o_b(){o_b=Kqb;!cLb&&(cLb=new dLb);gcc();kcc((z_b(),v_b),true,false)}\nfunction Hsd(a){this.a=new Isd(this);this.b=new Ksd(this);this.c=new Msd(this);this.d=new Osd(this);this.e=a}\nfunction Rsd(a){var b,c;if(!a.c){c=new ysd(VBb(PFb(a.a)),(b=Ssd(a),b),Qsd(a));AEb((SFb(a.a),c),MHb(SFb(a.a)));a.c=c}return a.c}\nfunction Gsd(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,A,B,C,D,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,ab,bb,cb,db,eb,fb,gb,hb,ib,jb,kb,lb,mb,nb,ob,pb,qb,rb,sb;b=new vbc;hLb(b,(c=new R_b,hLb(c,(j=new Gad,As(ho(j.a),(bsb(),(new Rrb(csb(B0e))).a)),jA(j,B0e),j)),hLb(c,(k=new Yie,yRb(k.a,O_e),ARb(k.a),(Jsb(),k.rb).style[ZPe]=($w(),gQe),BRb(k.a,'jQuery-Mask-Plugin 1.14.10'),k)),hLb(c,(l=new R_b,hLb(l,(m=new q_b,Chc((!m.V&&(m.V=new Ehc(m)),m.V),tOe),ho(m.D).setAttribute(xPe,'eg: 000-00-0000000'),Jdd(m.A).length==0||qo(m.A,sIe),Kdd(m.A,'Phone Number'),(ho(m.D).getAttribute(xPe)||'').length==0||qo(m.A,sIe),m.a='000-00-0000000',m)),hLb(l,(n=new q_b,Chc((!n.V&&(n.V=new Ehc(n)),n.V),tOe),ho(n.D).setAttribute(xPe,'eg: (00) 0000-0000'),Jdd(n.A).length==0||qo(n.A,sIe),Kdd(n.A,'Phone with Odd'),(ho(n.D).getAttribute(xPe)||'').length==0||qo(n.A,sIe),n.a='(00) 0000-0000',n)),hLb(l,(o=new q_b,Chc((!o.V&&(o.V=new Ehc(o)),o.V),tOe),ho(o.D).setAttribute(xPe,'eg: (000) 000-000'),Jdd(o.A).length==0||qo(o.A,sIe),Kdd(o.A,'US Phone Number'),(ho(o.D).getAttribute(xPe)||'').length==0||qo(o.A,sIe),o.a='(000) 000-000',o)),l)),hLb(c,(p=new R_b,hLb(p,(q=new q_b,Chc((!q.V&&(q.V=new Ehc(q)),q.V),tOe),ho(q.D).setAttribute(xPe,'eg: 00000-000'),Jdd(q.A).length==0||qo(q.A,sIe),Kdd(q.A,'CEP'),(ho(q.D).getAttribute(xPe)||'').length==0||qo(q.A,sIe),q.a='00000-000',q)),hLb(p,(r=new q_b,Chc((!r.V&&(r.V=new Ehc(r)),r.V),tOe),ho(r.D).setAttribute(xPe,'eg: 000.000.000-00'),Jdd(r.A).length==0||qo(r.A,sIe),Kdd(r.A,'CPF'),(ho(r.D).getAttribute(xPe)||'').length==0||qo(r.A,sIe),r.a='000.000.000-00',r)),hLb(p,(s=new q_b,Chc((!s.V&&(s.V=new Ehc(s)),s.V),tOe),ho(s.D).setAttribute(xPe,'eg: 000,000,000,000,000.00'),Jdd(s.A).length==0||qo(s.A,sIe),Kdd(s.A,'Money'),(ho(s.D).getAttribute(xPe)||'').length==0||qo(s.A,sIe),s.a='000,000,000,000,000.00',s)),p)),hLb(c,(t=new R_b,hLb(t,(u=new q_b,Chc((!u.V&&(u.V=new Ehc(u)),u.V),tOe),ho(u.D).setAttribute(xPe,C0e),Jdd(u.A).length==0||qo(u.A,sIe),Kdd(u.A,D0e),(ho(u.D).getAttribute(xPe)||'').length==0||qo(u.A,sIe),u.a=E0e,u)),hLb(t,(v=new q_b,Chc((!v.V&&(v.V=new Ehc(v)),v.V),tOe),ho(v.D).setAttribute(xPe,F0e),Jdd(v.A).length==0||qo(v.A,sIe),Kdd(v.A,G0e),(ho(v.D).getAttribute(xPe)||'').length==0||qo(v.A,sIe),v.a=H0e,v)),hLb(t,(w=new q_b,Chc((!w.V&&(w.V=new Ehc(w)),w.V),tOe),ho(w.D).setAttribute(xPe,I0e),Jdd(w.A).length==0||qo(w.A,sIe),Kdd(w.A,J0e),(ho(w.D).getAttribute(xPe)||'').length==0||qo(w.A,sIe),w.a=K0e,w)),t)),hLb(c,(A=new dje,Vdd(A,(B=new Bte,B.a+='\\u2003&lt;m:MaterialRow&gt;<br> \\u2003&lt;ma:inputmask.MaterialInputMask label=\"Phone Number\" placeholder=\"eg: 000-00-0000000\" mask=\"000-00-0000000\" grid=\"s12 m4 l4\"/&gt;<br> \\u2003&lt;ma:inputmask.MaterialInputMask label=\"Phone with Odd\" placeholder=\"eg: (00) 0000-0000\" mask=\"(00) 0000-0000\" grid=\"s12 m4 l4\"/&gt;<br> \\u2003&lt;ma:inputmask.MaterialInputMask label=\"US Phone Number\" placeholder=\"eg: (000) 000-000\" mask=\"(000) 000-000\" grid=\"s12 m4 l4\"/&gt;<br> &lt;/m:MaterialRow&gt;<br> &lt;m:MaterialRow&gt;<br> \\u2003&lt;ma:inputmask.MaterialInputMask label=\"CEP\" placeholder=\"eg: 00000-000\" mask=\"00000-000\" grid=\"s12 m4 l4\"/&gt;<br> \\u2003&lt;ma:inputmask.MaterialInputMask label=\"CPF\" placeholder=\"eg: 000.000.000-00\" mask=\"000.000.000-00\" grid=\"s12 m4 l4\"/&gt;<br> \\u2003&lt;ma:inputmask.MaterialInputMask label=\"Money\" placeholder=\"eg: 000,000,000,000,000.00\" mask=\"000,000,000,000,000.00\" grid=\"s12 m4 l4\"/&gt;<br> &lt;/m:MaterialRow&gt;<br> &lt;m:MaterialRow&gt;<br> \\u2003&lt;ma:inputmask.MaterialInputMask label=\"Ip Address\" placeholder=\"eg: 000.000.000.000\" mask=\"000.000.000.000\" grid=\"s12 m4 l4\"/&gt;<br> \\u2003&lt;ma:inputmask.MaterialInputMask label=\"Percentage\" placeholder=\"eg: 000000.00%\" mask=\"000000.00%\" grid=\"s12 m4 l4\"/&gt;<br> \\u2003&lt;ma:inputmask.MaterialInputMask label=\"Credit Card\" placeholder=\"eg: 0000 0000 0000 0000\" mask=\"0000 0000 0000 0000\" grid=\"s12 m4 l4\"/&gt;<br> &lt;/m:MaterialRow&gt;<br>',new Lrb(B.a)).a),yo(A.rb,vPe,true),A)),yo(c.rb,TLe,true),c));hLb(b,(d=new R_b,hLb(d,(C=new Gad,Tdd(C.b,'The mask will be placed from the right to the left if reverse is true (Default : false)'),As(ho(C.a),(new Rrb(csb('Reverse'))).a),jA(C,'Reverse'),C)),hLb(d,(D=new R_b,hLb(D,(F=new q_b,Chc((!F.V&&(F.V=new Ehc(F)),F.V),tOe),ho(F.D).setAttribute(xPe,C0e),Jdd(F.A).length==0||qo(F.A,sIe),Kdd(F.A,D0e),(ho(F.D).getAttribute(xPe)||'').length==0||qo(F.A,sIe),F.b.reverse=true,F.a=E0e,F)),hLb(D,(G=new q_b,Chc((!G.V&&(G.V=new Ehc(G)),G.V),tOe),ho(G.D).setAttribute(xPe,F0e),Jdd(G.A).length==0||qo(G.A,sIe),Kdd(G.A,G0e),(ho(G.D).getAttribute(xPe)||'').length==0||qo(G.A,sIe),G.b.reverse=true,G.a=H0e,G)),hLb(D,(H=new q_b,Chc((!H.V&&(H.V=new Ehc(H)),H.V),tOe),ho(H.D).setAttribute(xPe,I0e),Jdd(H.A).length==0||qo(H.A,sIe),Kdd(H.A,J0e),(ho(H.D).getAttribute(xPe)||'').length==0||qo(H.A,sIe),H.b.reverse=true,H.a=K0e,H)),D)),hLb(d,(I=new dje,Vdd(I,(J=new Bte,J.a+='&lt;ma:inputmask.MaterialInputMask label=\"Ip Address\" placeholder=\"eg: 000.000.000.000\" mask=\"000.000.000.000\" reverse=\"true\" grid=\"s12 m4 l4\"/&gt;<br> &lt;ma:inputmask.MaterialInputMask label=\"Percentage\" placeholder=\"eg: 000000.00%\" mask=\"000000.00%\" reverse=\"true\" grid=\"s12 m4 l4\"/&gt;<br> &lt;ma:inputmask.MaterialInputMask label=\"Credit Card\" placeholder=\"eg: 0000 0000 0000 0000\" mask=\"0000 0000 0000 0000\" reverse=\"true\" grid=\"s12 m4 l4\"/&gt;<br>',new Lrb(J.a)).a),yo(I.rb,vPe,true),I)),yo(d.rb,TLe,true),d));hLb(b,(e=new R_b,hLb(e,(K=new Gad,Tdd(K.b,'The textfield will automatically clears whenever the value is not match with the mask provided. (Default : false)'),As(ho(K.a),(new Rrb(csb(L0e))).a),jA(K,L0e),K)),hLb(e,(L=new R_b,hLb(L,(M=new q_b,Chc((!M.V&&(M.V=new Ehc(M)),M.V),tOe),M.b.clearIfNotMatch=true,ho(M.D).setAttribute(xPe,C0e),Jdd(M.A).length==0||qo(M.A,sIe),Kdd(M.A,D0e),(ho(M.D).getAttribute(xPe)||'').length==0||qo(M.A,sIe),M.a=E0e,M)),hLb(L,(N=new q_b,Chc((!N.V&&(N.V=new Ehc(N)),N.V),tOe),N.b.clearIfNotMatch=true,ho(N.D).setAttribute(xPe,F0e),Jdd(N.A).length==0||qo(N.A,sIe),Kdd(N.A,G0e),(ho(N.D).getAttribute(xPe)||'').length==0||qo(N.A,sIe),N.a=H0e,N)),hLb(L,(O=new q_b,Chc((!O.V&&(O.V=new Ehc(O)),O.V),tOe),O.b.clearIfNotMatch=true,ho(O.D).setAttribute(xPe,I0e),Jdd(O.A).length==0||qo(O.A,sIe),Kdd(O.A,J0e),(ho(O.D).getAttribute(xPe)||'').length==0||qo(O.A,sIe),O.a=K0e,O)),L)),hLb(e,(P=new dje,Vdd(P,(Q=new Bte,Q.a+='&lt;ma:inputmask.MaterialInputMask label=\"Ip Address\" placeholder=\"eg: 000.000.000.000\" mask=\"000.000.000.000\" clearIfNotMatch=\"true\" grid=\"s12 m4 l4\"/&gt;<br> &lt;ma:inputmask.MaterialInputMask label=\"Percentage\" placeholder=\"eg: 000000.00%\" mask=\"000000.00%\" clearIfNotMatch=\"true\" grid=\"s12 m4 l4\"/&gt;<br> &lt;ma:inputmask.MaterialInputMask label=\"Credit Card\" placeholder=\"eg: 0000 0000 0000 0000\" mask=\"0000 0000 0000 0000\" clearIfNotMatch=\"true\" grid=\"s12 m4 l4\"/&gt;<br>',new Lrb(Q.a)).a),yo(P.rb,vPe,true),P)),yo(e.rb,TLe,true),e));hLb(b,(f=new R_b,hLb(f,(R=new Gad,Tdd(R.b,'Set whether you want to set on focus on your mask for easy selection.'),As(ho(R.a),(new Rrb(csb(M0e))).a),jA(R,M0e),R)),hLb(f,(S=new R_b,hLb(S,(T=new q_b,Chc((!T.V&&(T.V=new Ehc(T)),T.V),tOe),T.b.selectOnFocus=true,ho(T.D).setAttribute(xPe,C0e),Jdd(T.A).length==0||qo(T.A,sIe),Kdd(T.A,D0e),(ho(T.D).getAttribute(xPe)||'').length==0||qo(T.A,sIe),T.a=E0e,T)),hLb(S,(U=new q_b,Chc((!U.V&&(U.V=new Ehc(U)),U.V),tOe),U.b.selectOnFocus=true,ho(U.D).setAttribute(xPe,F0e),Jdd(U.A).length==0||qo(U.A,sIe),Kdd(U.A,G0e),(ho(U.D).getAttribute(xPe)||'').length==0||qo(U.A,sIe),U.a=H0e,U)),hLb(S,(V=new q_b,Chc((!V.V&&(V.V=new Ehc(V)),V.V),tOe),V.b.selectOnFocus=true,ho(V.D).setAttribute(xPe,I0e),Jdd(V.A).length==0||qo(V.A,sIe),Kdd(V.A,J0e),(ho(V.D).getAttribute(xPe)||'').length==0||qo(V.A,sIe),V.a=K0e,V)),S)),hLb(f,(W=new dje,Vdd(W,(X=new Bte,X.a+='&lt;ma:inputmask.MaterialInputMask label=\"Ip Address\" placeholder=\"eg: 000.000.000.000\" mask=\"000.000.000.000\" selectOnFocus=\"true\" grid=\"s12 m4 l4\"/&gt;<br> &lt;ma:inputmask.MaterialInputMask label=\"Percentage\" placeholder=\"eg: 000000.00%\" mask=\"000000.00%\" selectOnFocus=\"true\" grid=\"s12 m4 l4\"/&gt;<br> &lt;ma:inputmask.MaterialInputMask label=\"Credit Card\" placeholder=\"eg: 0000 0000 0000 0000\" mask=\"0000 0000 0000 0000\" selectOnFocus=\"true\" grid=\"s12 m4 l4\"/&gt;<br>',new Lrb(X.a)).a),yo(W.rb,vPe,true),W)),yo(f.rb,TLe,true),f));hLb(b,(g=new R_b,hLb(g,(Y=new Gad,Tdd(Y.b,'Gets the value of the field with the mask.'),As(ho(Y.a),(new Rrb(csb($$e))).a),jA(Y,$$e),Y)),hLb(g,(Z=new R_b,hLb(Z,($=new q_b,Chc((!$.V&&($.V=new Ehc($)),$.V),tOe),ho($.D).setAttribute(xPe,C0e),Jdd($.A).length==0||qo($.A,sIe),Kdd($.A,D0e),(ho($.D).getAttribute(xPe)||'').length==0||qo($.A,sIe),$.b.reverse=true,$.a=E0e,a.e.b=$,$)),hLb(Z,(ab=new s2c,hLb(ab,(bb=new SRb,$Sb(bb.j,$$e),bb.j.mb||hLb(bb,bb.j),lLb(bb,a.b),bb)),Chc((!ab.V&&(ab.V=new Ehc(ab)),ab.V),wPe),ab)),Z)),hLb(g,(cb=new dje,Vdd(cb,(db=new Bte,db.a+='inputMask.getValue();',new Lrb(db.a)).a),yo(cb.rb,BPe,true),cb)),yo(g.rb,TLe,true),g));hLb(b,(h=new R_b,hLb(h,(eb=new Gad,Tdd(eb.b,'Gets the value of the field without the mask.'),As(ho(eb.a),(new Rrb(csb(N0e))).a),jA(eb,N0e),eb)),hLb(h,(fb=new R_b,hLb(fb,(gb=new q_b,Chc((!gb.V&&(gb.V=new Ehc(gb)),gb.V),tOe),ho(gb.D).setAttribute(xPe,C0e),Jdd(gb.A).length==0||qo(gb.A,sIe),Kdd(gb.A,D0e),(ho(gb.D).getAttribute(xPe)||'').length==0||qo(gb.A,sIe),gb.b.reverse=true,gb.a=E0e,a.e.a=gb,gb)),hLb(fb,(hb=new s2c,hLb(hb,(ib=new SRb,$Sb(ib.j,N0e),ib.j.mb||hLb(ib,ib.j),lLb(ib,a.a),ib)),Chc((!hb.V&&(hb.V=new Ehc(hb)),hb.V),wPe),hb)),fb)),hLb(h,(jb=new dje,Vdd(jb,(kb=new Bte,kb.a+='inputMask.getCleanValue();',new Lrb(kb.a)).a),yo(jb.rb,BPe,true),jb)),yo(h.rb,TLe,true),h));hLb(b,(i=new R_b,hLb(i,(lb=new Gad,Tdd(lb.b,'Programmatically controls the Input Mask main methods.'),As(ho(lb.a),(new Rrb(csb(O0e))).a),jA(lb,O0e),lb)),hLb(i,(mb=new R_b,hLb(mb,(nb=new q_b,Chc((!nb.V&&(nb.V=new Ehc(nb)),nb.V),tOe),ho(nb.D).setAttribute(xPe,C0e),Jdd(nb.A).length==0||qo(nb.A,sIe),Kdd(nb.A,D0e),(ho(nb.D).getAttribute(xPe)||'').length==0||qo(nb.A,sIe),nb.b.reverse=true,nb.a=E0e,a.e.c=nb,nb)),hLb(mb,(ob=new s2c,hLb(ob,(pb=new SRb,pb.rb.style[wIe]=oRe,bMb(pb,(ppc(),apc)),$Sb(pb.j,'Unmask'),pb.j.mb||hLb(pb,pb.j),DMb(pb,Pkc),lLb(pb,a.c),pb)),hLb(ob,(qb=new SRb,$Sb(qb.j,'mask'),qb.j.mb||hLb(qb,qb.j),lLb(qb,a.d),qb)),Chc((!ob.V&&(ob.V=new Ehc(ob)),ob.V),wPe),ob)),mb)),hLb(i,(rb=new dje,Vdd(rb,(sb=new Bte,sb.a+='\\u2003inputMask.mask(\"00.00\"); <br> inputMask.unmask();',new Lrb(sb.a)).a),yo(rb.rb,BPe,true),rb)),yo(i.rb,TLe,true),i));return b}\nvar A0e='gwt.material.design.addins.client.inputmask',B0e='Basic Examples',C0e='eg: 000.000.000.000',D0e='Ip Address',E0e='000.000.000.000',F0e='eg: 000000.00%',G0e='Percentage',H0e='000000.00%',I0e='eg: 0000 0000 0000 0000',J0e='Credit Card',K0e='0000 0000 0000 0000',L0e='Clear If not Match',M0e='Select on Focus',N0e='Get Clean Value',O0e='Unmask and Mask control';Jqb(145,117,cKe,q_b);_.Te=function r_b(){this.a==null||this.a.length==0?(gs(),gs()):p_b(this,this.a)};_.Ec=function s_b(){U$b(this);this.a==null||this.a.length==0?(gs(),gs()):p_b(this,this.a)};_.Fc=function t_b(){!this.W&&(this.W=new TUc(this));QUc(this.W);$wnd.$(ho(zD(this.D,205))).unmask()};_.Ue=function u_b(){$wnd.$(ho(zD(this.D,205))).unmask()};var XN=Mre(A0e,'MaterialInputMask',145);var v_b;Jqb(2727,1,{},w_b);_.Fd=function x_b(){return 'inputMaskJs'};_.Gd=function y_b(){var a;a=new Bte;a.a+=\"/**\\n * jquery.mask.js\\n * @version: v1.14.10\\n * @author: Igor Escobar\\n *\\n * Created by Igor Escobar on 2012-03-10. Please report any bug at http://blog.igorescobar.com\\n *\\n * Copyright (c) 2012 Igor Escobar http://blog.igorescobar.com\\n *\\n * The MIT License (http://www.opensource.org/licenses/mit-license.php)\\n *\\n * Permission is hereby granted, free of charge, to any person\\n * obtaining a copy of this software and associated documentation\\n * files (the \\\"Software\\\"), to deal in the Software without\\n * restriction, including without limitation the rights to use,\\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\\n * copies of the Software, and to permit persons to whom the\\n * Software is furnished to do so, subject to the following\\n * conditions:\\n *\\n * The above copyright notice and this permission notice shall be\\n * included in all copies or substantial portions of the Software.\\n *\\n * THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND,\\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\\n * OTHER DEALINGS IN THE SOFTWARE.\\n */\\n\\n/* jshint laxbreak: true */\\n/* jshint maxcomplexity:17 */\\n/* global define */\\n\\n'use strict';\\n\\n// UMD (Universal Module Definition) patterns for JavaScript modules that work everywhere.\\n// https://github.com/umdjs/umd/blob/master/jqueryPluginCommonjs.js\\n(function (factory, jQuery, Zepto) {\\n\\n    if (typeof define === 'function' && define.amd) {\\n        define(['jquery'], factory);\\n    } else if (typeof exports === 'object') {\\n        module.exports = factory(require('jquery'));\\n    } else {\\n        factory(jQuery || Zepto);\\n    }\\n\\n}(function ($) {\\n\\n    var Mask = function (el, mask, options) {\\n\\n        var p = {\\n            invalid: [],\\n            getCaret: function () {\\n                try {\\n                    var sel,\\n                        pos = 0,\\n                        ctrl = el.get(0),\\n                        dSel = document.selection,\\n                        cSelStart = ctrl.selectionStart;\\n\\n                    // IE Support\\n                    if (dSel && navigator.appVersion.indexOf('MSIE 10') === -1) {\\n                        sel = dSel.createRange();\\n                        sel.moveStart('character', -p.val().length);\\n                        pos = sel.text.length;\\n                    }\\n                    // Firefox support\\n                    else if (cSelStart || cSelStart === '0') {\\n                        pos = cSelStart;\\n                    }\\n\\n                    return pos;\\n                } catch (e) {}\\n            },\\n            setCaret: function(pos) {\\n                try {\\n                    if (el.is(':focus')) {\\n                        var range, ctrl = el.get(0);\\n\\n                        // Firefox, WebKit, etc..\\n                        if (ctrl.setSelectionRange) {\\n                            ctrl.setSelectionRange(pos, pos);\\n                        } else { // IE\\n                            range = ctrl.createTextRange();\\n                            range.collapse(true);\\n                            range.moveEnd('character', pos);\\n                            range.moveStart('character', pos);\\n                            range.select();\\n                        }\\n                    }\\n                } catch (e) {}\\n            },\\n            events: function() {\\n                el\\n                    .on('keydown.mask', function(e) {\\n                        el.data('mask-keycode', e.keyCode || e.which);\\n                        el.data('mask-previus-value', el.val());\\n                    })\\n                    .on($.jMaskGlobals.useInput ? 'input.mask' : 'keyup.mask', p.behaviour)\\n                    .on('paste.mask drop.mask', function() {\\n                        setTimeout(function() {\\n                            el.keydown().keyup();\\n                        }, 100);\\n                    })\\n                    .on('change.mask', function(){\\n                        el.data('changed', true);\\n                    })\\n                    .on('blur.mask', function(){\\n                        if (oldValue !== p.val() && !el.data('changed')) {\\n                            el.trigger('change');\\n                        }\\n                        el.data('changed', false);\\n                    })\\n                    // it's very important that this callback remains in this position\\n                    // otherwhise oldValue it's going to work buggy\\n                    .on('blur.mask', function() {\\n                        oldValue = p.val();\\n                    })\\n                    // select all text on focus\\n                    .on('focus.mask', function (e) {\\n                        if (options.selectOnFocus === true) {\\n                            $(e.target).select();\\n                        }\\n                    })\\n                    // clear the value if it not complete the mask\\n                    .on('focusout.mask', function() {\\n                        if (options.clearIfNotMatch && !regexMask.test(p.val())) {\\n                            p.val('');\\n                        }\\n                    });\\n            },\\n            getRegexMask: function() {\\n                var maskChunks = [], translation, pattern, optional, recursive, oRecursive, r;\\n\\n                for (var i = 0; i < mask.length; i++) {\\n                    translation = jMask.translation[mask.charAt(i)];\\n\\n                    if (translation) {\\n\\n                        pattern = translation.pattern.toString().replace(/.{1}$|^.{1}/g, '');\\n                        optional = translation.optional;\\n                        recursive = translation.recursive;\\n\\n                        if (recursive) {\\n                            maskChunks.push(mask.charAt(i));\\n                            oRecursive = {digit: mask.charAt(i), pattern: pattern};\\n                        } else {\\n                            maskChunks.push(!optional && !recursive ? pattern : (pattern + '?'));\\n                        }\\n\\n                    } else {\\n                        maskChunks.push(mask.charAt(i).replace(/[-\\\\/\\\\\\\\^$*+?.()|[\\\\]{}]/g, '\\\\\\\\$&'));\\n                    }\\n                }\\n\\n                r = maskChunks.join('');\\n\\n                if (oRecursive) {\\n                    r = r.replace(new RegExp('(' + oRecursive.digit + '(.*' + oRecursive.digit + ')?)'), '($1)?')\\n                        .replace(new RegExp(oRecursive.digit, 'g'), oRecursive.pattern);\\n                }\\n\\n                return new RegExp(r);\\n            },\\n            destroyEvents: function() {\\n                el.off(['input', 'keydown', 'keyup', 'paste', 'drop', 'blur', 'focusout', ''].join('.mask '));\\n            },\\n            val: function(v) {\\n                var isInput = el.is('input'),\\n                    method = isInput ? 'val' : 'text',\\n                    r;\\n\\n                if (arguments.length > 0) {\\n                    if (el[method]() !== v) {\\n                        el[method](v);\\n                    }\\n                    r = el;\\n                } else {\\n                    r = el[method]();\\n                }\\n\\n                return r;\\n            },\\n            calculateCaretPosition: function(caretPos, newVal) {\\n                var newValL = newVal.length,\\n                    oValue  = el.data('mask-previus-value') || '',\\n                    oValueL = oValue.length;\\n\\n                // edge cases when erasing digits\\n                if (el.data('mask-keycode') === 8 && oValue !== newVal) {\\n                    caretPos = caretPos - (newVal.slice(0, caretPos).length - oValue.slice(0, caretPos).length);\\n\\n                    // edge cases when typing new digits\\n                } else if (oValue !== newVal) {\\n                    // if the cursor is at the end keep it there\\n                    if (caretPos >= oValueL) {\\n                        caretPos = newValL;\\n                    } else {\\n                        caretPos = caretPos + (newVal.slice(0, caretPos).length - oValue.slice(0, caretPos).length);\\n                    }\\n                }\\n\\n                return caretPos;\\n            },\\n            behaviour: function(e) {\\n                e = e || window.event;\\n                p.invalid = [];\\n\\n                var keyCode = el.data('mask-keycode');\\n\\n                if ($.inArray(keyCode, jMask.byPassKeys) === -1) {\\n                    var newVal   = p.getMasked(),\\n                        caretPos = p.getCaret();\\n\\n                    setTimeout(function(caretPos, newVal) {\\n                        p.setCaret(p.calculateCaretPosition(caretPos, newVal));\\n                    }, 10, caretPos, newVal);\\n\\n                    p.val(newVal);\\n                    p.setCaret(caretPos);\\n                    return p.callbacks(e);\\n                }\\n            },\\n            getMasked: function(skipMaskChars, val) {\\n                var buf = [],\\n                    value = val === undefined ? p.val() : val + '',\\n                    m = 0, maskLen = mask.length,\\n                    v = 0, valLen = value.length,\\n                    offset = 1, addMethod = 'push',\\n                    resetPos = -1,\\n                    lastMaskChar,\\n                    check;\\n\\n                if (options.reverse) {\\n                    addMethod = 'unshift';\\n                    offset = -1;\\n                    lastMaskChar = 0;\\n                    m = maskLen - 1;\\n                    v = valLen - 1;\\n                    check = function () {\\n                        return m > -1 && v > -1;\\n                    };\\n                } else {\\n                    lastMaskChar = maskLen - 1;\\n                    check = function () {\\n                        return m < maskLen && v < valLen;\\n                    };\\n                }\\n\\n                var lastUntranslatedMaskChar;\\n                while (check()) {\\n                    var maskDigit = mask.charAt(m),\\n                        valDigit = value.charAt(v),\\n                        translation = jMask.translation[maskDigit];\\n\\n                    if (translation) {\\n                        if (valDigit.match(translation.pattern)) {\\n                            buf[addMethod](valDigit);\\n                            if (translation.recursive) {\\n                                if (resetPos === -1) {\\n                                    resetPos = m;\\n                                } else if (m === lastMaskChar) {\\n                                    m = resetPos - offset;\\n                                }\\n\\n                                if (lastMaskChar === resetPos) {\\n                                    m -= offset;\\n                                }\\n                            }\\n                            m += offset;\\n                        } else if (valDigit === lastUntranslatedMaskChar) {\\n                            // matched the last untranslated (raw) mask character that we encountered\\n                            // likely an insert offset the mask character from the last entry; fall\\n                            // through and only increment v\\n                            lastUntranslatedMaskChar = undefined;\\n                        } else if (translation.optional) {\\n                            m += offset;\\n                            v -= offset;\\n                        } else if (translation.fallback) {\\n                            buf[addMethod](translation.fallback);\\n                            m += offset;\\n                            v -= offset;\\n                        } else {\\n                            p.invalid.push({p: v, v: valDigit, e: translation.pattern});\\n                        }\\n                        v += offset;\\n                    } else {\\n                        if (!skipMaskChars) {\\n                            buf[addMethod](maskDigit);\\n                        }\\n\\n                        if (valDigit === maskDigit) {\\n                            v += offset;\\n                        } else {\\n                            lastUntranslatedMaskChar = maskDigit;\\n                        }\\n\\n                        m += offset;\\n                    }\\n                }\\n\\n                var lastMaskCharDigit = mask.charAt(lastMaskChar);\\n                if (maskLen === valLen + 1 && !jMask.translation[lastMaskCharDigit]) {\\n                    buf.push(lastMaskCharDigit);\\n                }\\n\\n                return buf.join('');\\n            },\\n            callbacks: function (e) {\\n                var val = p.val(),\\n                    changed = val !== oldValue,\\n                    defaultArgs = [val, e, el, options],\\n                    callback = function(name, criteria, args) {\\n                        if (typeof options[name] === 'function' && criteria) {\\n                            options[name].apply(this, args);\\n                        }\\n                    };\\n\\n                callback('onChange', changed === true, defaultArgs);\\n                callback('onKeyPress', changed === true, defaultArgs);\\n                callback('onComplete', val.length === mask.length, defaultArgs);\\n                callback('onInvalid', p.invalid.length > 0, [val, e, el, p.invalid, options]);\\n            }\\n        };\\n\\n        el = $(el);\\n        var jMask = this, oldValue = p.val(), regexMask;\\n\\n        mask = typeof mask === 'function' ? mask(p.val(), undefined, el,  options) : mask;\\n\\n        // public methods\\n        jMask.mask = mask;\\n        jMask.options = options;\\n        jMask.remove = function() {\\n            var caret = p.getCaret();\\n            p.destroyEvents();\\n            p.val(jMask.getCleanVal());\\n            p.setCaret(caret);\\n            return el;\\n        };\\n\\n        // get value without mask\\n        jMask.getCleanVal = function() {\\n            return p.getMasked(true);\\n        };\\n\\n        // get masked value without the value being in the input or element\\n        jMask.getMaskedVal = function(val) {\\n            return p.getMasked(false, val);\\n        };\\n\\n        jMask.init = function(onlyMask) {\\n            onlyMask = onlyMask || false;\\n            options = options || {};\\n\\n            jMask.clearIfNotMatch  = $.jMaskGlobals.clearIfNotMatch;\\n            jMask.byPassKeys       = $.jMaskGlobals.byPassKeys;\\n            jMask.translation      = $.extend({}, $.jMaskGlobals.translation, options.translation);\\n\\n            jMask = $.extend(true, {}, jMask, options);\\n\\n            regexMask = p.getRegexMask();\\n\\n            if (onlyMask) {\\n                p.events();\\n                p.val(p.getMasked());\\n            } else {\\n                if (options.placeholder) {\\n                    el.attr('placeholder' , options.placeholder);\\n                }\\n\\n                // this is necessary, otherwise if the user submit the form\\n                // and then press the \\\"back\\\" button, the autocomplete will erase\\n                // the data. Works fine on IE9+, FF, Opera, Safari.\\n                if (el.data('mask')) {\\n                    el.attr('autocomplete', 'off');\\n                }\\n\\n                // detect if is necessary let the user type freely.\\n                // for is a lot faster than forEach.\\n                for (var i = 0, maxlength = true; i < mask.length; i++) {\\n                    var translation = jMask.translation[mask.charAt(i)];\\n                    if (translation && translation.recursive) {\\n                        maxlength = false;\\n                        break;\\n                    }\\n                }\\n\\n                if (maxlength) {\\n                    el.attr('maxlength', mask.length);\\n                }\\n\\n                p.destroyEvents();\\n                p.events();\\n\\n                var caret = p.getCaret();\\n                p.val(p.getMasked());\\n                p.setCaret(caret);\\n            }\\n        };\\n\\n        jMask.init(!el.is('input'));\\n    };\\n\\n    $.maskWatchers = {};\\n    var HTMLAttributes = function () {\\n            var input = $(this),\\n                options = {},\\n                prefix = 'data-mask-',\\n                mask = input.attr('data-mask');\\n\\n            if (input.attr(prefix + 'reverse')) {\\n                options.reverse = true;\\n            }\\n\\n            if (input.attr(prefix + 'clearifnotmatch')) {\\n              \";a.a+=\"  options.clearIfNotMatch = true;\\n            }\\n\\n            if (input.attr(prefix + 'selectonfocus') === 'true') {\\n                options.selectOnFocus = true;\\n            }\\n\\n            if (notSameMaskObject(input, mask, options)) {\\n                return input.data('mask', new Mask(this, mask, options));\\n            }\\n        },\\n        notSameMaskObject = function(field, mask, options) {\\n            options = options || {};\\n            var maskObject = $(field).data('mask'),\\n                stringify = JSON.stringify,\\n                value = $(field).val() || $(field).text();\\n            try {\\n                if (typeof mask === 'function') {\\n                    mask = mask(value);\\n                }\\n                return typeof maskObject !== 'object' || stringify(maskObject.options) !== stringify(options) || maskObject.mask !== mask;\\n            } catch (e) {}\\n        },\\n        eventSupported = function(eventName) {\\n            var el = document.createElement('div'), isSupported;\\n\\n            eventName = 'on' + eventName;\\n            isSupported = (eventName in el);\\n\\n            if ( !isSupported ) {\\n                el.setAttribute(eventName, 'return;');\\n                isSupported = typeof el[eventName] === 'function';\\n            }\\n            el = null;\\n\\n            return isSupported;\\n        };\\n\\n    $.fn.mask = function(mask, options) {\\n        options = options || {};\\n        var selector = this.selector,\\n            globals = $.jMaskGlobals,\\n            interval = globals.watchInterval,\\n            watchInputs = options.watchInputs || globals.watchInputs,\\n            maskFunction = function() {\\n                if (notSameMaskObject(this, mask, options)) {\\n                    return $(this).data('mask', new Mask(this, mask, options));\\n                }\\n            };\\n\\n        $(this).each(maskFunction);\\n\\n        if (selector && selector !== '' && watchInputs) {\\n            clearInterval($.maskWatchers[selector]);\\n            $.maskWatchers[selector] = setInterval(function(){\\n                $(document).find(selector).each(maskFunction);\\n            }, interval);\\n        }\\n        return this;\\n    };\\n\\n    $.fn.masked = function(val) {\\n        return this.data('mask').getMaskedVal(val);\\n    };\\n\\n    $.fn.unmask = function() {\\n        clearInterval($.maskWatchers[this.selector]);\\n        delete $.maskWatchers[this.selector];\\n        return this.each(function() {\\n            var dataMask = $(this).data('mask');\\n            if (dataMask) {\\n                dataMask.remove().removeData('mask');\\n            }\\n        });\\n    };\\n\\n    $.fn.cleanVal = function() {\\n        return this.data('mask').getCleanVal();\\n    };\\n\\n    $.applyDataMask = function(selector) {\\n        selector = selector || $.jMaskGlobals.maskElements;\\n        var $selector = (selector instanceof $) ? selector : $(selector);\\n        $selector.filter($.jMaskGlobals.dataMaskAttr).each(HTMLAttributes);\\n    };\\n\\n    var globals = {\\n        maskElements: 'input,td,span,div',\\n        dataMaskAttr: '*[data-mask]',\\n        dataMask: true,\\n        watchInterval: 300,\\n        watchInputs: true,\\n        // old versions of chrome dont work great with input event\\n        useInput: !/Chrome\\\\/[2-4][0-9]|SamsungBrowser/.test(window.navigator.userAgent) && eventSupported('input'),\\n        watchDataMask: false,\\n        byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],\\n        translation: {\\n            '0': {pattern: /\\\\d/},\\n            '9': {pattern: /\\\\d/, optional: true},\\n            '#': {pattern: /\\\\d/, recursive: true},\\n            'A': {pattern: /[a-zA-Z0-9]/},\\n            'S': {pattern: /[a-zA-Z]/}\\n        }\\n    };\\n\\n    $.jMaskGlobals = $.jMaskGlobals || {};\\n    globals = $.jMaskGlobals = $.extend(true, {}, globals, $.jMaskGlobals);\\n\\n    // looking for inputs with data-mask attribute\\n    if (globals.dataMask) {\\n        $.applyDataMask();\\n    }\\n\\n    setInterval(function() {\\n        if ($.jMaskGlobals.watchDataMask) {\\n            $.applyDataMask();\\n        }\\n    }, globals.watchInterval);\\n}, window.jQuery, window.Zepto));\\n\";return a.a};var WN=Mre(A0e,'MaterialInputMaskClientBundle_default_InlineClientBundleGenerator/1',2727);Jqb(920,55,eIe,ysd);_.ye=function zsd(){Whe();PEb(this,new Yhe(WWe,'An inputmask helps the user with the input by ensuring a predefined format. This can be useful for dates, numerics, phone numbers etc...','addins/inputmask/InputMask',''))};var T0=Mre(jRe,'InputMaskPresenter',920);Jqb(1298,63,fIe,Fsd);var Z0=Mre(jRe,'InputMaskView',1298);Jqb(1749,1,{},Hsd);var Y0=Mre(jRe,'InputMaskView_BinderImpl/Widgets',1749);Jqb(1750,1,KIe,Isd);_.jd=function Jsd(a){Pad($wnd.$(ho(zD(this.a.e.a.D,205))).cleanVal())};var U0=Mre(jRe,'InputMaskView_BinderImpl/Widgets/1',1750);Jqb(1751,1,KIe,Ksd);_.jd=function Lsd(a){Pad(FD(this.a.e.b.D.Sd()))};var V0=Mre(jRe,'InputMaskView_BinderImpl/Widgets/2',1751);Jqb(1752,1,KIe,Msd);_.jd=function Nsd(a){$wnd.$(ho(zD(this.a.e.c.D,205))).unmask()};var W0=Mre(jRe,'InputMaskView_BinderImpl/Widgets/3',1752);Jqb(1753,1,KIe,Osd);_.jd=function Psd(a){p_b(this.a.e.c,E0e)};var X0=Mre(jRe,'InputMaskView_BinderImpl/Widgets/4',1753);Jqb(767,1,SPe);_.Uc=function Ysd(){bJb(this.b,Rsd(this.a.a))};XDe(Eq)(10);\n//# sourceURL=gwtmaterialdemo-10.js\n")
